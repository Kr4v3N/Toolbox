#!/usr/bin/env python3

import argparse
import hashlib
import json
import magic
import os
import pefile
import time
import vt
import yara

from dotenv import load_dotenv
from oletools.olevba import VBA_Parser

def get_files(path):
    """
    Retourne la liste des fichiers dans un répertoire ou le fichier lui-même si c'est un fichier
    """
    if os.path.isdir(path):
        files = []
        for item in os.listdir(path):
            pth = os.path.join(path, item)
            if os.path.isfile(pth):
                files.append(pth)
        return files
    if os.path.isfile(path):
        return [path]

def get_md5(path):
    """
    Retourne l'empreinte MD5 d'un fichier
    """
    md5 = hashlib.md5()
    with open(path, 'rb') as f:
        chunk = f.read(4096)
        while len(chunk) > 0:
            md5.update(chunk)
            chunk = f.read(4096)
        return md5.hexdigest()

def get_file_hashes(path):
    """
    Retourne les empreintes MD5, SHA1 et SHA256 d'un fichier
    """
    md5 = hashlib.md5()
    sha1 = hashlib.sha1()
    sha256 = hashlib.sha256()
    with open(path, 'rb') as f:
        chunk = f.read(4096)
        while len(chunk) > 0:
            md5.update(chunk)
            sha1.update(chunk)
            sha256.update(chunk)
            chunk = f.read(4096)
        return {'md5': md5.hexdigest(), 'sha1': sha1.hexdigest(), 'sha256': sha256.hexdigest()}

def get_imphash(path):
    """
    Retourne l'empreinte "import hash" d'un fichier PE
    """
    try:
        pe = pefile.PE(path)
        return pe.get_imphash()
    except:
        return "[!] Erreur: En-tête PE non valide"

def match_yara(file_path, rule_path):
    """
    Vérifie si un fichier correspond à une règle Yara
    """
    rule = yara.compile(rule_path)
    matches = rule.match(file_path)
    for m in matches:
        print(" [!] :", m.rule)

def check_vt(path):
    """
    Vérifie un fichier sur VirusTotal en utilisant son empreinte md5
    """
    try:
        api_key = os.getenv("vt_key")
        client = vt.Client(api_key)
        file_hash = get_md5(path)
        res = client.get_object("/files/{}".format(file_hash))
        return {
            "found": True,
            "malicious": res.last_analysis_stats['malicious'],
            "classification": res.popular_threat_classification
        }
    except vt.error.APIError as e:
        return {"found": False, "msg": e.message}

def analyze_doc(path):
    # Crée un objet VBA_Parser à partir du chemin spécifié
    vb_parse = VBA_Parser(path)
    # Analyse les macros contenues dans le document
    vb_parse.analyze_macros()
    # Renvoie les résultats de l'analyse sous forme de chaîne de caractères JSON
    return json.dumps(vb_parse.analysis_results, indent=2, default=str)

def get_imports(path):
    try:
        # Ouvre le fichier PE à partir du chemin spécifié
        pe = pefile.PE(path)
        # Analyse les répertoires de données du fichier PE
        pe.parse_data_directories()
        total_functions = 0
        # Parcourt les entrées d'importation
        for entry in pe.DIRECTORY_ENTRY_IMPORT:
            # Ajoute le nombre de fonctions importées pour chaque entrée
            total_functions += len(entry.imports)
        # Affiche les informations sur les imports (nom de la DLL et nombre de fonctions importées)
        print("{0:>20} | dlls: {1:3} functions: {2:3}".format(
            path,
            len(pe.DIRECTORY_ENTRY_IMPORT),
            total_functions
        ))
    except:
        print("[!] Erreur: PE non valide")

def get_flags(section):
    """
    Retourne les flags de section d'un fichier PE
    """
    flags = ""
    # Vérifie si les flags de lecture, écriture et exécution sont activés
    if section.Characteristics & 0x40000000:
        flags += "R"
    if section.Characteristics & 0x80000000:
        flags += "W"
    if section.Characteristics & 0x20000000:
        flags += "X"
    return flags

def analyze_sections(path):
    try:
        # Ouvre le fichier PE à partir du chemin spécifié
        pe = pefile.PE(path)
        # Affiche le nom du fichier
        print(path)
        # Parcourt les sections du fichier PE
        for section in pe.sections:
            section_name = section.Name.decode().rstrip("\x00")
            # Affiche le nom de la section et ses flags
            print("  {0:6} | {1}".format(section_name, get_flags(section)))
        print()
    except:
        print("[!] Erreur: PE non valide")

if __name__ == "__main__":
    # Charge les variables d'environnement à partir d'un fichier .env
    load_dotenv()
    # Définit les arguments possibles pour l'exécution du script
    parser = argparse.ArgumentParser()
    parser.add_argument("path", help="Le chemin d'accès au fichier ou au répertoire correspondant")
    parser.add_argument("-s", "--file_summary", help="Obtenir le type de fichier et les hachages", action="store_true")
    parser.add_argument("-y", "--yara_scan", help="Analyser un fichier ou un répertoire à l'aide d'une règle Yara",
                        metavar="YARA_RULE_PATH")
    parser.add_argument("-vt", "--check_vt", help="Vérifier VirusTotal en fonction du hachage du fichier md5",
                        action="store_true")
    parser.add_argument("-ole", "--analyze_ole", help="Scanner un document  MS Office", action="store_true")
    parser.add_argument("-imp", "--analyze_imports", help="Obtenir le nombre de DLL et de fonctions",
                        action="store_true")
    parser.add_argument("-sec", "--analyze_pe_sections", help="Obtenir des drapeaux de section", action="store_true")
    args = parser.parse_args()

    # Vérifie si le chemin spécifié est valide
    if not os.path.exists(args.path):
        print("[!] Erreur: chemin non valide")
        exit()
    # Obtient une liste de fichiers à partir du chemin spécifié
    files = get_files(args.path)
    # Si l'argument --file_summary est utilisé, affiche les informations de type de fichier et les hachages
    if args.file_summary:
        for file in files:
            print("\n", file)
            fs = "{0:>10} : {1}"
            print(fs.format("type", magic.from_file(file)))
            hashes = get_file_hashes(file)
            print(fs.format("md5", hashes["md5"]))
            print(fs.format("sha1", hashes["sha1"]))
            print(fs.format("sha256", hashes["sha256"]))
            print(fs.format("imphash", get_imphash(file)))
        print()

    # Si l'argument --yara_scan est utilisé, effectue une analyse yara sur chaque fichier
    if args.yara_scan:
        if os.path.exists(args.yara_scan):
            for file in files:
                print(file)
                match_yara(file, args.yara_scan)
        else:
            print("[!] Erreur: Le chemin d'accès à la règle Yara n'est pas valide")

    # Si l'argument --check_vt est utilisé, vérifie chaque fichier avec VirusTotal
    if args.check_vt:
        for file in files:
            time.sleep(0.5)
            res = check_vt(file)
            if res["found"]:
                fs = "{0:>10} : {1}"
                print(fs.format("malicious", res["malicious"]))
                print(fs.format("classification", json.dumps(res["classification"], indent=2)))
            else:
                print("[!] Erreur: ", res["msg"])

    # Ce bloc de code exécutera la fonction analyze_doc() sur le fichier spécifié. La fonction analysera le fichier pour tout objet potentiel OLE (Object Linking and Embedding), qui est souvent utilisé dans les documents MS Office. La fonction renverra toutes les informations qu'elle trouve sur les objets OLE.
    if args.analyze_ole:
        if os.path.isfile(args.path):
            print(analyze_doc(args.path))

    # Ce bloc de code exécutera la fonction get_imports() sur chaque fichier de la liste 'files'. La fonction analysera le fichier pour toutes les DLL et fonctions importées, et imprimera les informations qu'elle trouve
    if args.analyze_imports:
        for file in files:
            get_imports(file)

    # Ce bloc de code exécutera la fonction analyze_sections() sur chaque fichier de la liste 'files'. La fonction analysera le fichier pour les différentes sections qu'il contient, et imprimera les drapeaux de section. Cela peut être utile pour déterminer le but des différentes parties du fichier
    if args.analyze_pe_sections:
        for file in files:
            analyze_sections(file)



